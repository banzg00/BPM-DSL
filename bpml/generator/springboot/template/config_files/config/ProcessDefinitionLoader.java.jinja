package {{ group_name }}.{{ app_name_lower }}.config;

import {{ group_name }}.{{ app_name_lower }}.model.ProcessDefinition;
import {{ group_name }}.{{ app_name_lower }}.repository.ProcessDefinitionRepository;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.CommandLineRunner;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;
import java.util.*;

/**
 * Loads process definitions into the database at application startup
 */
@Component
@RequiredArgsConstructor
@Slf4j
public class ProcessDefinitionLoader implements CommandLineRunner {

    private final ProcessDefinitionRepository processDefinitionRepository;
    private final ObjectMapper objectMapper;

    @Override
    public void run(String... args) throws Exception {
        log.info("Loading process definitions...");

        {% for process in processes %}
        loadProcessDefinition_{{ process.name }}();
        {% endfor %}

        log.info("Process definitions loaded successfully");
    }

    {% for process in processes %}
    private void loadProcessDefinition_{{ process.name }}() {
        String processName = "{{ process.name }}";

        // Check if already exists
        if (processDefinitionRepository.findByProcessName(processName).isPresent()) {
            log.info("Process definition '{}' already exists, skipping...", processName);
            return;
        }

        try {
            // Build process definition JSON
            Map<String, Object> definition = new HashMap<>();

            // States
            List<Map<String, String>> states = new ArrayList<>();
            {% for state in process.states %}
            states.add(Map.of("name", "{{ state.name }}", "type", "ACTIVE"));
            {% endfor %}
            definition.put("states", states);

            // Final states (states with no outgoing transitions)
            List<String> finalStates = new ArrayList<>();
            {% set all_from_states = [] %}
            {% for transition in process.transitions %}
            {% set _ = all_from_states.append(transition.from_state.name) %}
            {% endfor %}
            {% for state in process.states %}
            {% if state.name not in all_from_states %}
            finalStates.add("{{ state.name }}");
            {% endif %}
            {% endfor %}
            definition.put("finalStates", finalStates);

            // Roles
            List<Map<String, Object>> roles = new ArrayList<>();
            {% for role in process.roles %}
            {
                Map<String, Object> role = new HashMap<>();
                role.put("name", "{{ role.name }}");
                {% if role.supervised_roles %}
                role.put("supervisedRoles", List.of({% for supervised in role.supervised_roles %}"{{ supervised.name }}"{% if not loop.last %}, {% endif %}{% endfor %}));
                {% endif %}
                roles.add(role);
            }
            {% endfor %}
            definition.put("roles", roles);

            // Role hierarchy (supervisor -> list of supervised roles)
            Map<String, List<String>> roleHierarchy = new HashMap<>();
            {% for role in process.roles %}
            {% if role.supervised_roles %}
            roleHierarchy.put("{{ role.name }}", List.of({% for supervised_role in role.supervised_roles %}"{{ supervised_role.name }}"{% if not loop.last %}, {% endif %}{% endfor %}));
            {% endif %}
            {% endfor %}
            definition.put("roleHierarchy", roleHierarchy);

            // Transitions
            List<Map<String, Object>> transitions = new ArrayList<>();
            {% for transition in process.transitions %}
            {
                Map<String, Object> t = new HashMap<>();
                t.put("name", "{{ transition.name }}");
                t.put("fromState", "{{ transition.from_state.name }}");
                t.put("toState", "{{ transition.to_state.name }}");
                {% if transition.role %}
                t.put("role", "{{ transition.role.name }}");
                {% endif %}
                transitions.add(t);
            }
            {% endfor %}
            definition.put("transitions", transitions);

            // Tasks
            List<Map<String, Object>> tasks = new ArrayList<>();
            {% for task in process.tasks %}
            {
                Map<String, Object> t = new HashMap<>();
                t.put("name", "{{ task.name }}");
                t.put("state", "{{ task.state.name }}");
                {% if task.role %}
                t.put("role", "{{ task.role.name }}");
                {% endif %}
                {% if task.auto %}
                t.put("auto", true);
                {% endif %}
                {% if task.entities %}
                t.put("entities", List.of({% for entity in task.entities %}"{{ entity.name }}"{% if not loop.last %}, {% endif %}{% endfor %}));
                {% endif %}
                {% if task.dependencies %}
                t.put("dependencies", List.of({% for dep_task in task.dependencies %}"{{ dep_task.name }}"{% if not loop.last %}, {% endif %}{% endfor %}));
                {% endif %}
                tasks.add(t);
            }
            {% endfor %}
            definition.put("tasks", tasks);

            // Convert to JSON
            String definitionJson = objectMapper.writeValueAsString(definition);

            // Find initial state (first state defined)
            String initialState = "{{ process.states[0].name if process.states else 'START' }}";

            // Create and save process definition
            ProcessDefinition processDefinition = ProcessDefinition.builder()
                    .processName(processName)
                    .version("1.0")
                    .description("{{ process.name }} process definition")
                    .definitionJson(definitionJson)
                    .initialState(initialState)
                    .createdAt(LocalDateTime.now())
                    .build();

            processDefinitionRepository.save(processDefinition);
            log.info("Loaded process definition: {}", processName);

        } catch (Exception e) {
            log.error("Failed to load process definition: {}", processName, e);
        }
    }
    {% endfor %}
}
