package {{ group_name }}.{{ app_name_lower }}.service;

import {{ group_name }}.{{ app_name_lower }}.dto.*;
import {{ group_name }}.{{ app_name_lower }}.model.*;
import {{ group_name }}.{{ app_name_lower }}.repository.*;
import {{ group_name }}.{{ app_name_lower }}.exception.NotFoundException;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Core process engine - orchestrates process execution
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class ProcessEngine {

    private final ProcessDefinitionRepository processDefinitionRepository;
    private final ProcessInstanceRepository processInstanceRepository;
    private final TaskInstanceRepository taskInstanceRepository;
    private final TransitionHistoryRepository transitionHistoryRepository;
    private final ObjectMapper objectMapper;

    {% for entity in all_entities %}
    private final {{ entity.name }}Repository {{ entity.name|lower }}Repository;
    {% endfor %}

    /**
     * Start a new process instance
     */
    @Transactional
    public ProcessInstanceDTO startProcess(String processName, StartProcessRequest request) {
        log.info("Starting process: {} by user: {}", processName, request.getInitiatedBy());

        // Load process definition
        ProcessDefinition definition = processDefinitionRepository.findByProcessName(processName)
                .orElseThrow(() -> new NotFoundException("Process definition not found: " + processName));

        // Parse process definition JSON to get initial state
        Map<String, Object> definitionMap = parseDefinitionJson(definition.getDefinitionJson());
        String initialState = definition.getInitialState();

        // Prepare process variables
        Map<String, Object> processVariables = request.getProcessVariables() != null
                ? new HashMap<>(request.getProcessVariables())
                : new HashMap<>();

        // Handle multiple entities if provided
        if (request.getEntities() != null && !request.getEntities().isEmpty()) {
            log.info("Processing {} entities for new process instance", request.getEntities().size());

            // Store entity references in process variables
            Map<String, List<Long>> entityIdsByType = new HashMap<>();
            List<String> entityTypes = new ArrayList<>();

            for (StartProcessRequest.EntityReference entityRef : request.getEntities()) {
                String entityType = entityRef.getEntityType();
                Long entityId = entityRef.getEntityId();
                log.debug("Adding entity: type={}, id={}", entityType, entityId);

                // Group entity IDs by type
                entityIdsByType.computeIfAbsent(entityType, k -> new ArrayList<>()).add(entityId);

                if (!entityTypes.contains(entityType)) {
                    entityTypes.add(entityType);
                }
            }

            // Store in process variables
            processVariables.put("entityTypes", entityTypes);
            processVariables.put("entityIdsByType", entityIdsByType);
            log.info("Stored entityIdsByType in process variables: {}", entityIdsByType);
        }

        // Create process instance
        ProcessInstance processInstance = ProcessInstance.builder()
                .processName(processName)
                .currentState(initialState)
                .status(ProcessInstance.ProcessStatus.RUNNING)
                .initiatedBy(request.getInitiatedBy())
                .processVariables(serializeToJson(processVariables))
                .startedAt(LocalDateTime.now())
                .build();

        ProcessInstance savedInstance = processInstanceRepository.save(processInstance);
        log.info("Created process instance {} in state {}", savedInstance.getId(), initialState);

        // Update linked entities with processInstanceId
        if (request.getEntities() != null && !request.getEntities().isEmpty()) {
            linkEntitiesToProcess(savedInstance.getId(), request.getEntities());
        }

        // Create initial tasks for the initial state
        createTasksForState(savedInstance, initialState, definitionMap);

        return mapToProcessInstanceDTO(savedInstance);
    }

    /**
     * Execute a transition
     */
    @Transactional
    public ProcessInstanceDTO executeTransition(Long processInstanceId, String transitionName, ExecuteTransitionRequest request) {
        log.info("Executing transition {} on process instance {} by user {}",
                transitionName, processInstanceId, request.getUserId());

        // Load process instance
        ProcessInstance processInstance = processInstanceRepository.findById(processInstanceId)
                .orElseThrow(() -> new NotFoundException("Process instance not found: " + processInstanceId));

        if (processInstance.getStatus() == ProcessInstance.ProcessStatus.SUSPENDED) {
            throw new IllegalStateException("Cannot execute transition on suspended process. Please resume the process first.");
        }

        if (processInstance.getStatus() != ProcessInstance.ProcessStatus.RUNNING) {
            throw new IllegalStateException("Cannot execute transition on non-running process. Current status: " + processInstance.getStatus());
        }

        // Load process definition
        ProcessDefinition definition = processDefinitionRepository.findByProcessName(processInstance.getProcessName())
                .orElseThrow(() -> new NotFoundException("Process definition not found: " + processInstance.getProcessName()));

        Map<String, Object> definitionMap = parseDefinitionJson(definition.getDefinitionJson());

        // Find the transition
        Map<String, Object> transition = findTransition(definitionMap, transitionName);
        if (transition == null) {
            throw new NotFoundException("Transition not found: " + transitionName);
        }

        // Validate transition
        String fromState = (String) transition.get("fromState");
        String toState = (String) transition.get("toState");
        String requiredRole = (String) transition.get("role");

        if (!processInstance.getCurrentState().equals(fromState)) {
            throw new IllegalStateException(String.format(
                    "Invalid transition. Process is in state '%s' but transition '%s' requires state '%s'",
                    processInstance.getCurrentState(), transitionName, fromState));
        }

        if (requiredRole != null && request.getUserRole() != null && !request.getUserRole().equals(requiredRole)) {
            throw new IllegalStateException(String.format(
                    "User role '%s' is not authorized for transition '%s'. Required role: '%s'",
                    request.getUserRole(), transitionName, requiredRole));
        }

        // Check if all tasks for current state are completed
        List<TaskInstance> incompleteTasks = taskInstanceRepository.findByProcessInstanceId(processInstanceId)
                .stream()
                .filter(task -> task.getStatus() != TaskInstance.TaskStatus.COMPLETED &&
                               task.getStatus() != TaskInstance.TaskStatus.CANCELLED)
                .collect(Collectors.toList());

        if (!incompleteTasks.isEmpty()) {
            String taskNames = incompleteTasks.stream()
                    .map(TaskInstance::getTaskName)
                    .collect(Collectors.joining(", "));
            throw new IllegalStateException(String.format(
                    "Cannot execute transition. %d task(s) must be completed first: %s",
                    incompleteTasks.size(), taskNames));
        }

        // Record transition history
        TransitionHistory history = TransitionHistory.builder()
                .processInstanceId(processInstanceId)
                .transitionName(transitionName)
                .fromState(fromState)
                .toState(toState)
                .executedBy(request.getUserId())
                .executedByRole(request.getUserRole())
                .transitionData(serializeToJson(request.getTransitionData()))
                .executedAt(LocalDateTime.now())
                .build();
        transitionHistoryRepository.save(history);

        // Update process state
        String oldState = processInstance.getCurrentState();
        processInstance.setCurrentState(toState);

        // Complete tasks associated with the old state
        completeTasksForState(processInstanceId, oldState, request.getUserId());

        // Check if process has reached a final state
        List<String> finalStates = getFinalStates(definitionMap);
        if (finalStates.contains(toState)) {
            processInstance.setStatus(ProcessInstance.ProcessStatus.COMPLETED);
            processInstance.setCompletedAt(LocalDateTime.now());
            log.info("Process instance {} completed in state {}", processInstanceId, toState);
        }

        ProcessInstance updatedInstance = processInstanceRepository.save(processInstance);

        // Create new tasks for the new state (if not final)
        if (processInstance.getStatus() == ProcessInstance.ProcessStatus.RUNNING) {
            createTasksForState(updatedInstance, toState, definitionMap);
        }

        log.info("Transition {} executed successfully. Process moved from {} to {}",
                transitionName, fromState, toState);

        return mapToProcessInstanceDTO(updatedInstance);
    }

    /**
     * Get available transitions for current state
     */
    @Transactional(readOnly = true)
    public List<AvailableTransitionDTO> getAvailableTransitions(Long processInstanceId, String userRole) {
        log.info("Getting available transitions for process instance {} with role {}", processInstanceId, userRole);

        ProcessInstance processInstance = processInstanceRepository.findById(processInstanceId)
                .orElseThrow(() -> new NotFoundException("Process instance not found: " + processInstanceId));

        // Return empty list if process is not running
        if (processInstance.getStatus() != ProcessInstance.ProcessStatus.RUNNING) {
            log.info("Process instance {} is not running (status: {}), returning empty transitions",
                    processInstanceId, processInstance.getStatus());
            return Collections.emptyList();
        }

        ProcessDefinition definition = processDefinitionRepository.findByProcessName(processInstance.getProcessName())
                .orElseThrow(() -> new NotFoundException("Process definition not found: " + processInstance.getProcessName()));

        Map<String, Object> definitionMap = parseDefinitionJson(definition.getDefinitionJson());
        List<Map<String, Object>> transitions = getTransitions(definitionMap);

        String currentState = processInstance.getCurrentState();

        return transitions.stream()
                .filter(t -> currentState.equals(t.get("fromState")))
                .map(t -> {
                    String requiredRole = (String) t.get("role");
                    boolean canExecute = userRole == null || requiredRole == null || userRole.equals(requiredRole);

                    return AvailableTransitionDTO.builder()
                            .transitionName((String) t.get("name"))
                            .fromState((String) t.get("fromState"))
                            .toState((String) t.get("toState"))
                            .requiredRole(requiredRole)
                            .canExecute(canExecute)
                            .build();
                })
                .collect(Collectors.toList());
    }

    /**
     * Get process history
     */
    @Transactional(readOnly = true)
    public List<TransitionHistoryDTO> getProcessHistory(Long processInstanceId) {
        log.info("Getting history for process instance {}", processInstanceId);

        List<TransitionHistory> history = transitionHistoryRepository
                .findByProcessInstanceIdOrderByExecutedAtAsc(processInstanceId);

        return history.stream()
                .map(this::mapToTransitionHistoryDTO)
                .collect(Collectors.toList());
    }

    /**
     * Terminate a process instance
     */
    @Transactional
    public void terminateProcess(Long processInstanceId, String reason, String userId) {
        log.info("Terminating process instance {} by user {}. Reason: {}", processInstanceId, userId, reason);

        ProcessInstance processInstance = processInstanceRepository.findById(processInstanceId)
                .orElseThrow(() -> new NotFoundException("Process instance not found: " + processInstanceId));

        processInstance.setStatus(ProcessInstance.ProcessStatus.TERMINATED);
        processInstance.setTerminatedReason(reason);
        processInstance.setCompletedAt(LocalDateTime.now());
        processInstanceRepository.save(processInstance);

        // Cancel all pending tasks
        List<TaskInstance> pendingTasks = taskInstanceRepository
                .findByProcessInstanceId(processInstanceId);
        pendingTasks.forEach(task -> {
            if (task.getStatus() == TaskInstance.TaskStatus.PENDING ||
                task.getStatus() == TaskInstance.TaskStatus.IN_PROGRESS) {
                task.setStatus(TaskInstance.TaskStatus.CANCELLED);
            }
        });
        taskInstanceRepository.saveAll(pendingTasks);

        log.info("Process instance {} terminated", processInstanceId);
    }

    /**
     * Suspend a process instance (temporary pause)
     */
    @Transactional
    public ProcessInstanceDTO suspendProcess(Long processInstanceId, String reason, String userId) {
        log.info("Suspending process instance {} by user {}. Reason: {}", processInstanceId, userId, reason);

        ProcessInstance processInstance = processInstanceRepository.findById(processInstanceId)
                .orElseThrow(() -> new NotFoundException("Process instance not found: " + processInstanceId));

        if (processInstance.getStatus() != ProcessInstance.ProcessStatus.RUNNING) {
            throw new IllegalStateException("Can only suspend RUNNING processes. Current status: " + processInstance.getStatus());
        }

        processInstance.setStatus(ProcessInstance.ProcessStatus.SUSPENDED);
        processInstance.setSuspendedAt(LocalDateTime.now());
        processInstance.setSuspendedReason(reason);
        processInstance.setSuspendedBy(userId);

        ProcessInstance savedInstance = processInstanceRepository.save(processInstance);
        log.info("Process instance {} suspended", processInstanceId);

        return mapToProcessInstanceDTO(savedInstance);
    }

    /**
     * Resume a suspended process instance
     */
    @Transactional
    public ProcessInstanceDTO resumeProcess(Long processInstanceId, String userId) {
        log.info("Resuming process instance {} by user {}", processInstanceId, userId);

        ProcessInstance processInstance = processInstanceRepository.findById(processInstanceId)
                .orElseThrow(() -> new NotFoundException("Process instance not found: " + processInstanceId));

        if (processInstance.getStatus() != ProcessInstance.ProcessStatus.SUSPENDED) {
            throw new IllegalStateException("Can only resume SUSPENDED processes. Current status: " + processInstance.getStatus());
        }

        processInstance.setStatus(ProcessInstance.ProcessStatus.RUNNING);
        // Clear suspension fields
        processInstance.setSuspendedAt(null);
        processInstance.setSuspendedReason(null);
        processInstance.setSuspendedBy(null);

        ProcessInstance savedInstance = processInstanceRepository.save(processInstance);
        log.info("Process instance {} resumed", processInstanceId);

        return mapToProcessInstanceDTO(savedInstance);
    }

    // ===== PRIVATE HELPER METHODS =====

    private void createTasksForState(ProcessInstance processInstance, String state, Map<String, Object> definitionMap) {
        List<Map<String, Object>> steps = getSteps(definitionMap);

        // Find steps associated with this state (simple heuristic - can be enhanced)
        steps.forEach(step -> {
            String stepName = (String) step.get("name");
            String role = (String) step.get("role");

            String affectedEntities = null;

            @SuppressWarnings("unchecked")
            List<String> entitiesList = (List<String>) step.get("entities");
            if (entitiesList != null && !entitiesList.isEmpty()) {
                affectedEntities = String.join(",", entitiesList);
            }

            TaskInstance task = TaskInstance.builder()
                    .processInstanceId(processInstance.getId())
                    .taskName(stepName)
                    .assignedRole(role)
                    .status(TaskInstance.TaskStatus.PENDING)
                    .entityTypes(affectedEntities)
                    .createdAt(LocalDateTime.now())
                    .build();

            taskInstanceRepository.save(task);
            log.debug("Created task {} for process instance {} in state {}", stepName, processInstance.getId(), state);
        });
    }

    private void completeTasksForState(Long processInstanceId, String state, String userId) {
        List<TaskInstance> tasks = taskInstanceRepository.findByProcessInstanceId(processInstanceId);
        tasks.stream()
                .filter(t -> t.getStatus() == TaskInstance.TaskStatus.PENDING ||
                            t.getStatus() == TaskInstance.TaskStatus.IN_PROGRESS)
                .forEach(task -> {
                    task.setStatus(TaskInstance.TaskStatus.COMPLETED);
                    task.setCompletedAt(LocalDateTime.now());
                    task.setCompletedBy(userId);
                });
        taskInstanceRepository.saveAll(tasks);
    }

    private Map<String, Object> findTransition(Map<String, Object> definitionMap, String transitionName) {
        List<Map<String, Object>> transitions = getTransitions(definitionMap);
        return transitions.stream()
                .filter(t -> transitionName.equals(t.get("name")))
                .findFirst()
                .orElse(null);
    }

    @SuppressWarnings("unchecked")
    private List<Map<String, Object>> getTransitions(Map<String, Object> definitionMap) {
        return (List<Map<String, Object>>) definitionMap.getOrDefault("transitions", Collections.emptyList());
    }

    @SuppressWarnings("unchecked")
    private List<Map<String, Object>> getSteps(Map<String, Object> definitionMap) {
        return (List<Map<String, Object>>) definitionMap.getOrDefault("steps", Collections.emptyList());
    }

    @SuppressWarnings("unchecked")
    private List<String> getFinalStates(Map<String, Object> definitionMap) {
        return (List<String>) definitionMap.getOrDefault("finalStates", Collections.emptyList());
    }

    private Map<String, Object> parseDefinitionJson(String json) {
        if (json == null || json.isEmpty()) {
            return Collections.emptyMap();
        }
        try {
            return objectMapper.readValue(json, Map.class);
        } catch (JsonProcessingException e) {
            log.error("Failed to parse process definition JSON", e);
            return Collections.emptyMap();
        }
    }

    private String serializeToJson(Map<String, Object> data) {
        if (data == null) {
            return null;
        }
        try {
            return objectMapper.writeValueAsString(data);
        } catch (JsonProcessingException e) {
            log.error("Failed to serialize data to JSON", e);
            return "{}";
        }
    }

    private ProcessInstanceDTO mapToProcessInstanceDTO(ProcessInstance instance) {
        // Extract linked entities from process variables
        Map<String, Object> processVariables = parseDefinitionJson(instance.getProcessVariables());
        List<ProcessInstanceDTO.EntityReference> linkedEntities = new ArrayList<>();

        log.debug("Mapping process instance {} to DTO. Process variables keys: {}",
                  instance.getId(), processVariables.keySet());

        if (processVariables.containsKey("entityIdsByType")) {
            log.debug("Found entityIdsByType in process variables");
            try {
                @SuppressWarnings("unchecked")
                Map<String, Object> entityIdsByType = (Map<String, Object>) processVariables.get("entityIdsByType");
                log.debug("entityIdsByType value: {}", entityIdsByType);

                for (Map.Entry<String, Object> entry : entityIdsByType.entrySet()) {
                    String entityType = entry.getKey();
                    Object entityIdsObj = entry.getValue();
                    log.debug("Processing entity type: {}, IDs object: {}", entityType, entityIdsObj);

                    // Handle both List and array types
                    List<?> entityIdsList;
                    if (entityIdsObj instanceof List) {
                        entityIdsList = (List<?>) entityIdsObj;
                    } else {
                        log.warn("Unexpected type for entity IDs: {}", entityIdsObj.getClass());
                        continue;
                    }

                    // Convert each ID to Long, handling Integer, Long, or other numeric types
                    for (Object entityIdObj : entityIdsList) {
                        Long entityId = null;
                        if (entityIdObj instanceof Number) {
                            entityId = ((Number) entityIdObj).longValue();
                        } else {
                            log.warn("Unexpected entity ID type: {}", entityIdObj.getClass());
                            continue;
                        }

                        linkedEntities.add(ProcessInstanceDTO.EntityReference.builder()
                                .entityType(entityType)
                                .entityId(entityId)
                                .build());
                    }
                }
                log.info("Extracted {} linked entities for process instance {}", linkedEntities.size(), instance.getId());
            } catch (Exception e) {
                log.error("Error extracting linked entities from process variables", e);
            }
        } else {
            log.debug("No entityIdsByType found in process variables for instance {}", instance.getId());
        }

        return ProcessInstanceDTO.builder()
                .id(instance.getId())
                .processName(instance.getProcessName())
                .currentState(instance.getCurrentState())
                .status(instance.getStatus())
                .initiatedBy(instance.getInitiatedBy())
                .processVariables(processVariables)
                .startedAt(instance.getStartedAt())
                .completedAt(instance.getCompletedAt())
                .terminatedReason(instance.getTerminatedReason())
                .suspendedAt(instance.getSuspendedAt())
                .suspendedReason(instance.getSuspendedReason())
                .suspendedBy(instance.getSuspendedBy())
                .linkedEntities(linkedEntities)
                .build();
    }

    private TransitionHistoryDTO mapToTransitionHistoryDTO(TransitionHistory history) {
        return TransitionHistoryDTO.builder()
                .id(history.getId())
                .processInstanceId(history.getProcessInstanceId())
                .transitionName(history.getTransitionName())
                .fromState(history.getFromState())
                .toState(history.getToState())
                .executedBy(history.getExecutedBy())
                .executedByRole(history.getExecutedByRole())
                .transitionData(parseDefinitionJson(history.getTransitionData()))
                .executedAt(history.getExecutedAt())
                .build();
    }

    /**
     * Link multiple entities to a process instance
     */
    private void linkEntitiesToProcess(Long processInstanceId, List<StartProcessRequest.EntityReference> entities) {
        for (StartProcessRequest.EntityReference entityRef : entities) {
            String entityType = entityRef.getEntityType();
            Long entityId = entityRef.getEntityId();

            try {
                {% for entity in all_entities %}
                if ("{{ entity.name }}".equals(entityType)) {
                    {{ entity.name|lower }}Repository.updateProcessInstanceId(entityId, processInstanceId);
                    log.debug("Linked {} entity {} to process instance {}", entityType, entityId, processInstanceId);
                }
                {% endfor %}
            } catch (Exception e) {
                log.error("Failed to link entity {} of type {} to process instance {}",
                         entityId, entityType, processInstanceId, e);
            }
        }
    }
}
